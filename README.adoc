= Pathtracer

A pathtracer written in go (golang) for testing out pathtracing ideas and algorithms as well as learning the go programming language.

.The Go Gopher mascot rendered by the pathtracer
image::documentation/images/go_gopher.png[Go Gopher]

== Galleries

Some fancy images created during development can be found in the link:documentation/gallery/gallery.adoc[Gallery].

Images created to display certain core functionality of the raytracer can be found in the link:documentation/functionality/functionality.adoc[Functionality Gallery].

== How to run

=== Execute pathtracer

The renderer accepts a render scene file as program argument.

There are several go programs in the `cmd` directory that will create a scene file.
Run one of those programs to create a scene file.

=== Build and run path tracer for a scene file

You can use the script to conveniently build and execute a scene file creation program and then build and run the pathtracer for that created scene file. The script was created for macOS zshell.

The produced result will end up in the `rendered` directory.

`% .build_and_render_animation.sh <animation name>`

Animation name is the same as the directory name for the main file for the scene file.
For example:

`% .build_and_render_animation.sh cornellbox`

This will build and run the rendering of a cornell box image.

=== For the very first time

You will need to install "go" compiler of fairly recent version (v18+) on your computer to be able to compile the pathtracer (and scene-file creating programs).
The pathtracer itself do not rely on many 3:rd party libraries, so you should be just fine compiling after updating those few and fairly small libraries.

The installation instruction steps below assume that you have git and brew already installed.

As I have a lot of "big" images in this repo, textures and such, I use `git lfs` (Large File Storage) to make them not affect my github quota that much.
The installation show how to install the git lfs plugin. It will not alter or affect your git functionality but rather just add to set of git commands.

[source,shell]
----
brew install go

brew install git-lfs

git lfs install

cd <wherever you want to git-clone your pathtracer to>

git clone git@github.com:chran554/pathtracer.git

cd pathtracer

mkdir scene

git lfs pull
----

[source,shell]
----
./build_and_render.sh cornellbox
----

Welcome into the world of pathtracing....

https://youtu.be/oXk-PPmH5ak?t=32[Robin Beck - The Very First Time]

[quote,Robin Beck: The Very First Time]
Like a break in the clouds and the first ray of sun +
I can feel it inside something new has begun +
And it's taking control of my body and mind +
It began when I heard I love you +
For the very first time +
For the very first time +

== Pathtracer feature summary

A lot of functionality is on display in the link:documentation/functionality/functionality.adoc[Functionality Gallery].

* Load scene-files (json-based file format) capable of multi frame animations.
* xref:documentation/functionality/functionality.adoc#cornell-box[Pathtracing] algorithm

* xref:documentation/functionality/functionality.adoc#primitives[Primitives]: sphere, disc (circle on plane), triangle (facet)
* Scene building - primitives in hierarchies and translation, scaling, and rotation on any level.
* Bounding boxes (orthogonal aligned and hierarchically arranged)
* Reading (and writing) of Wavefront `.obj` 3D object file format (along with accompanying `.mtl` file)
* Reading of `.ply` 3D object file format
* xref:documentation/functionality/functionality.adoc#material-reflection-fresnel-dielectricnon-conducting[Reflection - Fresnel (dielectric/non-conducting)]
* xref:documentation/functionality/functionality.adoc#material-reflection-glossy-and-roughness[Reflection - glossy & roughness] (mirror with roughness/brushed for metallic effects)
* xref:documentation/functionality/functionality.adoc#importance-sampling-cosine-weighted-hemisphere[Importance sampling - cosine weighted hemisphere sampling] (instead of uniform sampling)
* Color definitions by RGBA (A for alpha/transparency)
* Rendered image with alpha channel. Parts of image not covered by any object will be transparent.
* Gamma correction on loaded textures and on rendered image export.
* Texture from images with alpha channels (png file format primarily) for transparency.
* Texture projections: xref:documentation/functionality/functionality.adoc#image-projection---spherical[sphere] (equirectangular), xref:documentation/functionality/functionality.adoc#image-projection---cylindrical[cylindrical], xref:documentation/functionality/functionality.adoc#image-projection---parallel[parallel] (flat)
* Free position camera with any direction and any focal length.
* Super sampling: Anti-alias (random rays within the pixel for smooth edges)
* Super sampling: DOF - xref:documentation/functionality/dof/dof.adoc[Depth of field] (focus distance and "aperture size")
* Super sampling: DOF - Depth of field - xref:documentation/functionality/dof/dof.adoc[aperture shape] (free form shape)
* xref:documentation/functionality/functionality.adoc#smooth-vertex-normals[Smooth vertex normal calculation] for facet structures. (Non weighted, but with angle threshold for smoothing between facets.)
* Save rendered image in PNG-format
* Save rendered HDR (high dynamic range) image in RAW-format ("praw") for post light editing in separate application tool https://github.com/chran554/RawImageEditor[RawImageEditor].
* https://github.com/chran554/PathtracerMonitor[Progressive/recursive pixel rendering], producing a quite useful overview after only 5% rendering.
* Sending broadcast (UDP) messages of rendered pixels to render monitor https://github.com/chran554/PathtracerMonitor[PathtracerMonitor].

=== TODO

* Reflection - Fresnel (conductor/metal)
* Refraction - using refraction index (WIP - work in progress)
* Color absorption in gas and liquid (solid) using Beer-Lambert Law
* Fake haze (testing a spin-off idea from Beer-Lambert)
* Normal maps (and maybe bump maps)
* Multi textures with operations `average` (really `add` with normalize), `subtract` (with min level 0.0), and `multiply`.
* Vertex mapping to textures for facets.
* Texture pixel interpolation. Nearest neighbour, Bilinear, and Bicubic (using Cubic Hermite Spline)
* Validate obj-file writing for complex objects.
* ...